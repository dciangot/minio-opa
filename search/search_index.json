{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Guida per setup IAM-MINIO-OPA Riferimenti https://www.openpolicyagent.org/docs/latest/ https://docs.min.io/docs/minio-sts-quickstart-guide https://github.com/minio/minio/blob/master/docs/sts/opa.md GUIDA PER USER Gestire token con OIDC-agent WebUI Volume Posix S3 API GUIDA PER ADMIN OPA+IAM Server side encryption","title":"Home"},{"location":"#guida-per-setup-iam-minio-opa","text":"","title":"Guida per setup IAM-MINIO-OPA"},{"location":"#riferimenti","text":"https://www.openpolicyagent.org/docs/latest/ https://docs.min.io/docs/minio-sts-quickstart-guide https://github.com/minio/minio/blob/master/docs/sts/opa.md","title":"Riferimenti"},{"location":"#guida-per-user","text":"Gestire token con OIDC-agent WebUI Volume Posix S3 API","title":"GUIDA PER USER"},{"location":"#guida-per-admin","text":"OPA+IAM Server side encryption","title":"GUIDA PER ADMIN"},{"location":"Encryption/","text":"Usare Server Side Encryption \"MinIO uses a key-management-system (KMS) to support SSE-S3. If a client requests SSE-S3, or auto-encryption is enabled, the MinIO server encrypts each object with an unique object key which is protected by a master key managed by the KMS. MinIO supports commonly-used KMS implementations, like AWS-KMS or Hashicorp Vault via our KES project. KES makes it possible to scale your KMS horizontally with your storage infrastructure (MinIO clusters). Therefore, it wraps around the KMS implementation like this:\" +-------+ +-------+ | MinIO | | MinIO | +---+---+ +---+---+ | | +----+-------------------------+----+---- KMS | | | | | +--+--+ +--+--+ | | | KES +--+ +--+ KES | | | +-----+ | +-------+ | +-----+ | | +--+ Vault +--+ | | +-----+ | +-------+ | +-----+ | | | KES +--+ +--+ KES | | | +--+--+ +--+--+ | | | | | +----+-------------------------+----+---- KMS | | +---+---+ +---+---+ | MinIO | | MinIO | +-------+ +-------+ Per semplicita' di seguito proveremo il setup con un solo server KES e un server minio. Al posto di Vault la chiave verra' salvata su FS. Riferimenti https://docs.min.io/docs/how-to-secure-access-to-minio-server-with-tls https://docs.minio.io/docs/how-to-use-minio-s-server-side-encryption-with-aws-cli https://github.com/minio/kes/wiki/MinIO-Object-Storage#kes-server-setup https://github.com/minio/kes/wiki/Server-API Requirements Install make, docker e docker-compose porta 9000 aperta Client IAM per code-flow con redirect URIs: 'http:// :9000/minio/' 'http:// :9000/minio/login/openid Scaricare il repository: git clone https://github.com/dciangot/minio-opa.git && cd minio-opa # Install utility for self signed certificate generation sudo wget https://github.com/DODAS-TS/dodas-x509/releases/download/v0.0.2/dodas-x509 -O /usr/local/bin/dodas-x509 # Install Minio KES wget https://github.com/minio/kes/releases/latest/download/linux-amd64.zip unzip linux-amd64.zip sudo mv kes /usr/local/bin/ # Create folder for certificates and keys mkdir -p certs/CAs mkdir keys # Create folder for Minoi encryption test mkdir data_encrypt Generate self-signed certificates # Generate KES server certificate dodas-x509 --hostname 127 .0.0.1 --ca-path $PWD /certs/CAs --cert-path $PWD /certs --cert-name kes --ca-name KES # Generate Minio server certificate dodas-x509 --hostname <public IP minio> --ca-path $PWD /certs/CAs --cert-path $PWD /certs --cert-name minio --ca-name MINIO # Use the minio naming convention for certificates mv certs/minio.pem certs/public.crt mv certs/minio.key certs/private.key Creare utenti KES Definiamo un utente con permessi admin (root) e uno per il server Minio: # Creation of KES user root kes tool identity new --key = \"certs/root.key\" --cert = \"certs/root.cert\" root # Creation of KES user Minio kes tool identity new --key = \"certs/minio.key\" --cert = \"certs/minio.cert\" MinIO Adesso in cert dovrebbero essere stati create i certificati indicati, che puo' indicarci lo user ID di KES per questi certificati con: kes tool identity of certs/root.cert kes tool identity of certs/minio.cert File di configurazione KES Il file di configurazione ( kes.config ) per questo setup consiste nell'indicare i cert per TLS e quello per autorizzare Minio a ritirare e creare chiavi. address = \"0.0.0.0:7373\" root = \"<value obtained with: `kes tool identity of certs/root.cert`>\" [tls] key = \"kes.key\" cert = \"kes.pem\" [policy.prod-app] paths = [ \"/v1/key/create/my-minio-key\", \"/v1/key/generate/my-minio-key\" , \"/v1/key/decrypt/my-minio-key\" ] identities = [ \"<value obtained with: `kes tool identity of certs/minio.cert`>\" ] # We use the local filesystem for simplicity. # We could use Vault for instance. [keystore.fs] path = \"./keys\" # Choose a directory for the secret keys Docker Compose: minio, opa, kes version : '3.7' services : opa : image : openpolicyagent/opa:0.18.0 network_mode : host command : - \"run\" - \"--server\" - \"--log-level=debug\" - \"--log-format=text\" - \"--addr=0.0.0.0:8181\" - \"/policies\" volumes : - ./policies:/policies minio : network_mode : host image : dciangot/minio command : - \"server\" - \"--address\" - \":9000\" - \"/data\" environment : MINIO_POLICY_OPA_URL : http://localhost:8181/v1/data/httpapi/authz/allow MINIO_IDENTITY_OPENID_CLIENT_ID : <IAM client ID> MINIO_IDENTITY_OPENID_CONFIG_URL : https://iam-demo.cloud.cnaf.infn.it/.well-known/openid-configuration MINIO_KMS_KES_ENDPOINT : https://127.0.0.1:7373 MINIO_KMS_KES_CERT_FILE : /root/.minio/certs/minio.cert MINIO_KMS_KES_KEY_FILE : /root/.minio/certs/minio.key MINIO_KMS_KES_CA_PATH : /root/.minio/certs/kes.pem MINIO_KMS_KES_KEY_NAME : my-minio-key MINIO_KMS_AUTO_ENCRYPTION : 1 volumes : - ./data_encrypt:/data - ./certs:/root/.minio/certs kes : network_mode : host image : minio/kes command : - \"server\" - \"--mtls-auth=ignore\" - \"--config=/root/config/server-config.toml\" volumes : - ./certs:/root/certs - ./kes.config:/root/config/server-config.toml - ./keys:/keys Restart del docker compose precedente # Stop docker-compose down # Start docker-compose up -d Generare una chiave di cifratura per Minio Generiamo una chiave con l'utente minio: cd certs export KES_CLIENT_TLS_CERT_FILE = minio.cert export KES_CLIENT_TLS_KEY_FILE = minio.key kes key create my-minio-key -k cd - Ora in .keys dovrebbe essere apparsa la chiave. Dovrebbe essere tutto pronto per poter andare a https:// :9000 creare un bucket con l'utenza minioadmin:minioadmin (vedi istruzioni qui ). Tutto quello che verra' caricato nel bucket apparira' in ./data_encrypt . Per configurare il client per accesso admin: mc config host add --insecure myminio https://<indirizzo pubblico Minio>:9000 minioadmin minioadmin","title":"Server side encryption"},{"location":"Encryption/#usare-server-side-encryption","text":"\"MinIO uses a key-management-system (KMS) to support SSE-S3. If a client requests SSE-S3, or auto-encryption is enabled, the MinIO server encrypts each object with an unique object key which is protected by a master key managed by the KMS. MinIO supports commonly-used KMS implementations, like AWS-KMS or Hashicorp Vault via our KES project. KES makes it possible to scale your KMS horizontally with your storage infrastructure (MinIO clusters). Therefore, it wraps around the KMS implementation like this:\" +-------+ +-------+ | MinIO | | MinIO | +---+---+ +---+---+ | | +----+-------------------------+----+---- KMS | | | | | +--+--+ +--+--+ | | | KES +--+ +--+ KES | | | +-----+ | +-------+ | +-----+ | | +--+ Vault +--+ | | +-----+ | +-------+ | +-----+ | | | KES +--+ +--+ KES | | | +--+--+ +--+--+ | | | | | +----+-------------------------+----+---- KMS | | +---+---+ +---+---+ | MinIO | | MinIO | +-------+ +-------+ Per semplicita' di seguito proveremo il setup con un solo server KES e un server minio. Al posto di Vault la chiave verra' salvata su FS.","title":"Usare Server Side Encryption"},{"location":"Encryption/#riferimenti","text":"https://docs.min.io/docs/how-to-secure-access-to-minio-server-with-tls https://docs.minio.io/docs/how-to-use-minio-s-server-side-encryption-with-aws-cli https://github.com/minio/kes/wiki/MinIO-Object-Storage#kes-server-setup https://github.com/minio/kes/wiki/Server-API","title":"Riferimenti"},{"location":"Encryption/#requirements","text":"Install make, docker e docker-compose porta 9000 aperta Client IAM per code-flow con redirect URIs: 'http:// :9000/minio/' 'http:// :9000/minio/login/openid Scaricare il repository: git clone https://github.com/dciangot/minio-opa.git && cd minio-opa # Install utility for self signed certificate generation sudo wget https://github.com/DODAS-TS/dodas-x509/releases/download/v0.0.2/dodas-x509 -O /usr/local/bin/dodas-x509 # Install Minio KES wget https://github.com/minio/kes/releases/latest/download/linux-amd64.zip unzip linux-amd64.zip sudo mv kes /usr/local/bin/ # Create folder for certificates and keys mkdir -p certs/CAs mkdir keys # Create folder for Minoi encryption test mkdir data_encrypt","title":"Requirements"},{"location":"Encryption/#generate-self-signed-certificates","text":"# Generate KES server certificate dodas-x509 --hostname 127 .0.0.1 --ca-path $PWD /certs/CAs --cert-path $PWD /certs --cert-name kes --ca-name KES # Generate Minio server certificate dodas-x509 --hostname <public IP minio> --ca-path $PWD /certs/CAs --cert-path $PWD /certs --cert-name minio --ca-name MINIO # Use the minio naming convention for certificates mv certs/minio.pem certs/public.crt mv certs/minio.key certs/private.key","title":"Generate self-signed certificates"},{"location":"Encryption/#creare-utenti-kes","text":"Definiamo un utente con permessi admin (root) e uno per il server Minio: # Creation of KES user root kes tool identity new --key = \"certs/root.key\" --cert = \"certs/root.cert\" root # Creation of KES user Minio kes tool identity new --key = \"certs/minio.key\" --cert = \"certs/minio.cert\" MinIO Adesso in cert dovrebbero essere stati create i certificati indicati, che puo' indicarci lo user ID di KES per questi certificati con: kes tool identity of certs/root.cert kes tool identity of certs/minio.cert","title":"Creare utenti KES"},{"location":"Encryption/#file-di-configurazione-kes","text":"Il file di configurazione ( kes.config ) per questo setup consiste nell'indicare i cert per TLS e quello per autorizzare Minio a ritirare e creare chiavi. address = \"0.0.0.0:7373\" root = \"<value obtained with: `kes tool identity of certs/root.cert`>\" [tls] key = \"kes.key\" cert = \"kes.pem\" [policy.prod-app] paths = [ \"/v1/key/create/my-minio-key\", \"/v1/key/generate/my-minio-key\" , \"/v1/key/decrypt/my-minio-key\" ] identities = [ \"<value obtained with: `kes tool identity of certs/minio.cert`>\" ] # We use the local filesystem for simplicity. # We could use Vault for instance. [keystore.fs] path = \"./keys\" # Choose a directory for the secret keys","title":"File di configurazione KES"},{"location":"Encryption/#docker-compose-minio-opa-kes","text":"version : '3.7' services : opa : image : openpolicyagent/opa:0.18.0 network_mode : host command : - \"run\" - \"--server\" - \"--log-level=debug\" - \"--log-format=text\" - \"--addr=0.0.0.0:8181\" - \"/policies\" volumes : - ./policies:/policies minio : network_mode : host image : dciangot/minio command : - \"server\" - \"--address\" - \":9000\" - \"/data\" environment : MINIO_POLICY_OPA_URL : http://localhost:8181/v1/data/httpapi/authz/allow MINIO_IDENTITY_OPENID_CLIENT_ID : <IAM client ID> MINIO_IDENTITY_OPENID_CONFIG_URL : https://iam-demo.cloud.cnaf.infn.it/.well-known/openid-configuration MINIO_KMS_KES_ENDPOINT : https://127.0.0.1:7373 MINIO_KMS_KES_CERT_FILE : /root/.minio/certs/minio.cert MINIO_KMS_KES_KEY_FILE : /root/.minio/certs/minio.key MINIO_KMS_KES_CA_PATH : /root/.minio/certs/kes.pem MINIO_KMS_KES_KEY_NAME : my-minio-key MINIO_KMS_AUTO_ENCRYPTION : 1 volumes : - ./data_encrypt:/data - ./certs:/root/.minio/certs kes : network_mode : host image : minio/kes command : - \"server\" - \"--mtls-auth=ignore\" - \"--config=/root/config/server-config.toml\" volumes : - ./certs:/root/certs - ./kes.config:/root/config/server-config.toml - ./keys:/keys","title":"Docker Compose: minio, opa, kes"},{"location":"Encryption/#restart-del-docker-compose-precedente","text":"# Stop docker-compose down # Start docker-compose up -d","title":"Restart del docker compose precedente"},{"location":"Encryption/#generare-una-chiave-di-cifratura-per-minio","text":"Generiamo una chiave con l'utente minio: cd certs export KES_CLIENT_TLS_CERT_FILE = minio.cert export KES_CLIENT_TLS_KEY_FILE = minio.key kes key create my-minio-key -k cd - Ora in .keys dovrebbe essere apparsa la chiave. Dovrebbe essere tutto pronto per poter andare a https:// :9000 creare un bucket con l'utenza minioadmin:minioadmin (vedi istruzioni qui ). Tutto quello che verra' caricato nel bucket apparira' in ./data_encrypt . Per configurare il client per accesso admin: mc config host add --insecure myminio https://<indirizzo pubblico Minio>:9000 minioadmin minioadmin","title":"Generare una chiave di cifratura per Minio"},{"location":"Oidc/","text":"Setup oidc-agent per istanza IAM-demo Oidc-agent ci aiutera' a gestire in maniera automatica e sicura i nostri Token per l'accesso ai dati. Requirement Installare oidc-agent come descritto qui Far partire l'agente: eval ` oidc-agent ` Configurare l'account IAM-demo Iniziamo creando il nostro account con il nome demo : $ oidc-gen demo Ci verra' chiesto di scegliere il nome dello issuer. Scrivere https://iam-demo.cloud.cnaf.infn.it/ e premere invio [1] https://iam-escape.cloud.cnaf.infn.it/ [2] https://iam-demo.cloud.cnaf.infn.it/ [3] https://accounts.google.com/ [4] https://iam-test.indigo-datacloud.eu/ [5] https://iam.deep-hybrid-datacloud.eu/ [6] https://iam.extreme-datacloud.eu/ [7] https://b2access.eudat.eu/oauth2/ [8] https://b2access-integration.fz-juelich.de/oauth2 [9] https://unity.eudat-aai.fz-juelich.de/oauth2/ [10] https://unity.helmholtz-data-federation.de/oauth2/ [11] https://login.helmholtz-data-federation.de/oauth2/ [12] https://services.humanbrainproject.eu/oidc/ [13] https://aai.egi.eu/oidc/ [14] https://aai-dev.egi.eu/oidc [15] https://login.elixir-czech.org/oidc/ [16] https://oidc.scc.kit.edu/auth/realms/kit/ [17] https://wlcg.cloud.cnaf.infn.it/ Issuer [https://iam-escape.cloud.cnaf.infn.it/]: https://iam-demo.cloud.cnaf.infn.it/ Poi digitare max per richiedere tutti gli scope possibili e premere invio: This issuer supports the following scopes: openid profile email address phone offline_access Space delimited list of scopes or 'max' [openid profile offline_access]: max Ora dovrebbe apparire un messaggio del tipo: Registering Client ... Generating account configuration ... accepted To continue and approve the registered client visit the following URL in a Browser of your choice: https://iam-demo.cloud.cnaf.infn.it/authorize?response_type=code&client_id=c70edf20-51e6-3ae753c&redirect_uri=http://localhost:8080&scope=address phone openid email profile offline_access&access_type=offline&prompt=consent&state=0:BNF-HR38LjQ4MA&code_challenge_method=S256&code_challenge=brx7x6RuQI5rkzlkGwh2u2z7vCVctSlQ Se non si apre in automatico una finestra nel vostro browser copiate a mano il link prodotto e inseritelo nel vostro browser. Portate a fine il login on IAM. Se avete problemi di timeout durante il caricamento della pagina, riprovate fino a che non si apre e quando riuscite tornate al terminale. Se la sessione e' andata in timeout, sara' apparso un messaggio del tipo: Polling oidc-agent to get the generated account configuration ....................... Polling is boring. Already tried 20 times. I stop now. Please press Enter to try it again. Fate come dice e cliccate invio. Dovrebbe essere ora andato tutto a buon fine e vi verra' chiesto di immetere una password che serve per criptare le vostre credenziali: success The generated account config was successfully added to oidc-agent. You don't have to run oidc-add. Enter encryption password for account configuration 'demo': Inseritene una a scelta e proseguite. Il setup e' concluso. Controllate che tutto sia ok con: $ oidc-token demo eyJraWQiOiJyc2ExIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJlZjVmMTgzZC00ZDllLTRmMmEtOWRjNi0zZjEzNTlmMTliMzUiLCJpc3MiOiJodHRwczpcL1wvaWFtLWRlbW8uY2xvdWQuY25hZi5pbmZuLml0XC8iLCJuYW1lIjoiRGllZ28gQ2lhbmdvdHRpbmk.... Questo significa che il nostro agente riesce a ritirare correttamente i token dal servizio IAM. Per avere a disposizione questo tool su ogni sessione bash, includere nel vostro profile on in bashrc: eval ` oidc-keychain ` Inoltre potrebbe essere necessario ricaricare l'account demo dopo ogni riavvio del PC. Per farlo basta: oidc-gen --reauthenticate demo e seguire la procedura proposta.","title":"Setup OIDC-agent"},{"location":"Oidc/#setup-oidc-agent-per-istanza-iam-demo","text":"Oidc-agent ci aiutera' a gestire in maniera automatica e sicura i nostri Token per l'accesso ai dati.","title":"Setup oidc-agent per istanza IAM-demo"},{"location":"Oidc/#requirement","text":"Installare oidc-agent come descritto qui Far partire l'agente: eval ` oidc-agent `","title":"Requirement"},{"location":"Oidc/#configurare-laccount-iam-demo","text":"Iniziamo creando il nostro account con il nome demo : $ oidc-gen demo Ci verra' chiesto di scegliere il nome dello issuer. Scrivere https://iam-demo.cloud.cnaf.infn.it/ e premere invio [1] https://iam-escape.cloud.cnaf.infn.it/ [2] https://iam-demo.cloud.cnaf.infn.it/ [3] https://accounts.google.com/ [4] https://iam-test.indigo-datacloud.eu/ [5] https://iam.deep-hybrid-datacloud.eu/ [6] https://iam.extreme-datacloud.eu/ [7] https://b2access.eudat.eu/oauth2/ [8] https://b2access-integration.fz-juelich.de/oauth2 [9] https://unity.eudat-aai.fz-juelich.de/oauth2/ [10] https://unity.helmholtz-data-federation.de/oauth2/ [11] https://login.helmholtz-data-federation.de/oauth2/ [12] https://services.humanbrainproject.eu/oidc/ [13] https://aai.egi.eu/oidc/ [14] https://aai-dev.egi.eu/oidc [15] https://login.elixir-czech.org/oidc/ [16] https://oidc.scc.kit.edu/auth/realms/kit/ [17] https://wlcg.cloud.cnaf.infn.it/ Issuer [https://iam-escape.cloud.cnaf.infn.it/]: https://iam-demo.cloud.cnaf.infn.it/ Poi digitare max per richiedere tutti gli scope possibili e premere invio: This issuer supports the following scopes: openid profile email address phone offline_access Space delimited list of scopes or 'max' [openid profile offline_access]: max Ora dovrebbe apparire un messaggio del tipo: Registering Client ... Generating account configuration ... accepted To continue and approve the registered client visit the following URL in a Browser of your choice: https://iam-demo.cloud.cnaf.infn.it/authorize?response_type=code&client_id=c70edf20-51e6-3ae753c&redirect_uri=http://localhost:8080&scope=address phone openid email profile offline_access&access_type=offline&prompt=consent&state=0:BNF-HR38LjQ4MA&code_challenge_method=S256&code_challenge=brx7x6RuQI5rkzlkGwh2u2z7vCVctSlQ Se non si apre in automatico una finestra nel vostro browser copiate a mano il link prodotto e inseritelo nel vostro browser. Portate a fine il login on IAM. Se avete problemi di timeout durante il caricamento della pagina, riprovate fino a che non si apre e quando riuscite tornate al terminale. Se la sessione e' andata in timeout, sara' apparso un messaggio del tipo: Polling oidc-agent to get the generated account configuration ....................... Polling is boring. Already tried 20 times. I stop now. Please press Enter to try it again. Fate come dice e cliccate invio. Dovrebbe essere ora andato tutto a buon fine e vi verra' chiesto di immetere una password che serve per criptare le vostre credenziali: success The generated account config was successfully added to oidc-agent. You don't have to run oidc-add. Enter encryption password for account configuration 'demo': Inseritene una a scelta e proseguite. Il setup e' concluso. Controllate che tutto sia ok con: $ oidc-token demo eyJraWQiOiJyc2ExIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiJlZjVmMTgzZC00ZDllLTRmMmEtOWRjNi0zZjEzNTlmMTliMzUiLCJpc3MiOiJodHRwczpcL1wvaWFtLWRlbW8uY2xvdWQuY25hZi5pbmZuLml0XC8iLCJuYW1lIjoiRGllZ28gQ2lhbmdvdHRpbmk.... Questo significa che il nostro agente riesce a ritirare correttamente i token dal servizio IAM. Per avere a disposizione questo tool su ogni sessione bash, includere nel vostro profile on in bashrc: eval ` oidc-keychain ` Inoltre potrebbe essere necessario ricaricare l'account demo dopo ogni riavvio del PC. Per farlo basta: oidc-gen --reauthenticate demo e seguire la procedura proposta.","title":"Configurare l'account IAM-demo"},{"location":"Opa/","text":"Guida per setup IAM-MINIO-OPA Riferimenti https://www.openpolicyagent.org/docs/latest/ https://docs.min.io/docs/minio-sts-quickstart-guide https://github.com/minio/minio/blob/master/docs/sts/opa.md Prerequisiti Install make, docker e docker-compose porta 9000 aperta Client IAM per code-flow con redirect URIs: 'http:// :9000/minio/' 'http:// :9000/minio/login/openid Scaricare il repository: git clone https://github.com/dciangot/minio-opa.git && cd minio-opa Installazione docker-compose up o make install Per stop e start usare: make stop/start Test delle default OPA policies in questo setup andare alla porta http:// 9000 del sever e seguire la procedura di autenticazione una volta entrati si puo creare il solo bucket con il proprio cognome o nome.cognome all'interno di quel bucket e' possibile scrivere, leggere e creare cartelle dentro il bucket scratch tutti possono leggere e scaricare tutto, ma possono solo scrivere in scratch/<cognome> o, se mancante, crearla. Di seguito la spiegazione di come queste policy sono configurate in opa Esempio di creazione policy OPA usando token claims IAM in Minio Un tipico input che arriva al server OPA da Minio dopo l'autenticazione con token IAM e' in questa forma: { \"input\" : { \"account\" : \"Z........................BI\" , \"action\" : \"s3:CreateBucket\" , \"bucket\" : \"ciangottini\" , \"conditions\" : { \"Accept-Encoding\" : [ \"identity\" ], \"Authorization\" : [ \"AWS4-HMAC-SHA256 Credential=ZX4QOC80CNLHIBCLG7BI/20200423/us-east-1/s3/aws4_request, SignedHeaders=host;user-agent;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=2926934a3a1380ff8c80c20faeb187a2ddcc42b47a9075fb111987c890811618\" ], \"Content-Length\" : [ \"0\" ], \"CurrentTime\" : [ \"2020-04-23T09:09:31Z\" ], \"EpochTime\" : [ \"1587632971\" ], \"Referer\" : [ \"\" ], \"SecureTransport\" : [ \"false\" ], \"SourceIp\" : [ \"188.XX3.77.XX\" ], \"User-Agent\" : [ \"MinIO (Linux; x86_64) minio-py/5.0.10\" ], \"UserAgent\" : [ \"MinIO (Linux; x86_64) minio-py/5.0.10\" ], \"X-Amz-Content-Sha256\" : [ \"e3b.................852b855\" ], \"X-Amz-Date\" : [ \"20200423T090933Z\" ], \"X-Amz-Security-Token\" : [ \"eyJhbGciO............vqgpJO9vWgQ3oc3tDOnP4A\" ], \"accessKey\" : [ \"ZX4QOC80CNLHIBCLG7BI\" ], \"aud\" : [ \"b8.........................d0d9\" ], \"email\" : [ \"ciangottini@pg.infn.it\" ], \"iss\" : [ \"https://iam.cloud.infn.it/\" ], \"jti\" : [ \"ffe5...................ce4e\" ], \"kid\" : [ \"rsa1\" ], \"name\" : [ \"Diego Ciangottini\" ], \"organisation_name\" : [ \"infn-cc\" ], \"preferred_username\" : [ \"ciangottini@infn.it\" ], \"principaltype\" : [ \"User\" ], \"sub\" : [ \"2f8......................286\" ], \"userid\" : [ \"ZX................BI\" ], \"username\" : [ \"ZX4..................BI\" ] }, \"owner\" : false , { \"action\" : \"s3:GetObject\" }, \"object\" : \"\" , \"claims\" : { \"accessKey\" : \"................LG7BI\" , \"aud\" : \"b830.........................07d0d9\" , \"email\" : \"ciangottini@pg.infn.it\" , \"exp\" : 1587633250 , \"groups\" : [ \"developers\" ], \"iat\" : 1587632650 , \"iss\" : \"https://iam.cloud.infn.it/\" , \"jti\" : \"ffe5.......7ce4e\" , \"kid\" : \"rsa1\" , \"name\" : \"Diego Ciangottini\" , \"organisation_name\" : \"infn-cc\" , \"preferred_username\" : \"ciangottini@infn.it\" , \"sub\" : \"2f8d..............61d89286\" } Tutti questi parametri possono essere utilizzati da OPA per decidere se autorizzare o no la richiesta. Si vede inoltre che MINIO ha processato l' id_token dell'utente ricavandone i campi claims . Nel nostro esempio abbiamo due principali categorie di permessi: user e scratch . Nel primo vogliamo autorizzare praticamente qualsiasi operazione s3, mentre nell'altro, vogliamo che solo il list e il get dei file sia permesso. Questo e' rappresentato nel file di default policy che abbiamo creato con: package httpapi . authz import input default allow = false # role-permissions assignments rl_permissions : = { \"user\" : [{ \"action\" : \"s3:CreateBucket\" }, { \"action\" : \"s3:DeleteBucket\" }, { \"action\" : \"s3:DeleteObject\" }, { \"action\" : \"s3:GetObject\" }, { \"action\" : \"s3:ListAllMyBuckets\" }, { \"action\" : \"s3:ListBucket\" }, { \"action\" : \"s3:PutObject\" }], \"scratch\" : [{ \"action\" : \"s3:ListAllMyBuckets\" }, { \"action\" : \"s3:GetObject\" }, { \"action\" : \"s3:ListBucket\" }] } Ora possiamo decidere in quali casi applicare questi permessi sulla base degli input visti prima. Iniziamo dal bucket utente, vogliamo autorizzare a creare ed operare su un determinato bucket solo le richieste che arrivano con un claim di tipo email nelle forma <bucket name>@... . Cosi che nel caso IAM INFN cloud l'utente possa scrivere nel bucket a suo nome.cognome o cognome . # Allow users to manage their own data. allow { # Extract username from email username : = split ( lower ( input . claims . preferred_username ), \"@\" )[ 0 ] # verify that bucketname == username input . bucket == username # apply only when token auth happened # This is needed to keep admin user and password with full powers input . claims . organisation_name == \"infn-cc\" # Apply user permissions to this request permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } Per quanto riguarda il bucket scratch invece, vogliamo che chiunque abbia i permessi scratch definiti sopra, quindi: # Allow to retrieve and see data from other users in scratch area allow { input . bucket == \"scratch\" permissions : = rl_permissions [ \"scratch\" ] p : = permissions [ _ ] # check if the permission granted to r matches the user request p == { \"action\" : input . action } } Mentre per limitare un subrange di chiamate a path del tipo scratch/<cognome> abbiamo bisogno di prendere altri input dalla richiesta e verificarli come segue: allow { username : = split ( lower ( input . claims . preferred_username ), \"@\" )[ 0 ] ref : = input . conditions . Referer [ _ ] url : = concat ( \"/\" , [ \"^http://.*:9000/minio/scratch\" , username , \".*$\" ] ) re_match ( url , ref ) input . claims . organisation_name == \"infn-cc\" permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } Infine vogliamo mantenere tutti i poter per l'autenticazione user e password dell'admin: allow { input . account == \"minioadmin\" permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } A questo punto se non fossero gia incluse di default in questo deployment, potremmo inserire nuove policy in opa con un semplice curl: curl -X PUT --data-binary @policy.rego http://localhost:8181/v1/policies/users Debugging OPA I log sono visibili (per ora) in debug mode qui: docker logs --tail 2000 minio-opa_opa_1 Debugging Minio Installare client mc Configurarlo per accesso admin mc config host add myminio http://localhost:9000 minioadmin minioadmin stampare il trace http con mc admin trace myminio","title":"OPA and IAM"},{"location":"Opa/#guida-per-setup-iam-minio-opa","text":"","title":"Guida per setup IAM-MINIO-OPA"},{"location":"Opa/#riferimenti","text":"https://www.openpolicyagent.org/docs/latest/ https://docs.min.io/docs/minio-sts-quickstart-guide https://github.com/minio/minio/blob/master/docs/sts/opa.md","title":"Riferimenti"},{"location":"Opa/#prerequisiti","text":"Install make, docker e docker-compose porta 9000 aperta Client IAM per code-flow con redirect URIs: 'http:// :9000/minio/' 'http:// :9000/minio/login/openid Scaricare il repository: git clone https://github.com/dciangot/minio-opa.git && cd minio-opa","title":"Prerequisiti"},{"location":"Opa/#installazione","text":"docker-compose up o make install Per stop e start usare: make stop/start","title":"Installazione"},{"location":"Opa/#test-delle-default-opa-policies-in-questo-setup","text":"andare alla porta http:// 9000 del sever e seguire la procedura di autenticazione una volta entrati si puo creare il solo bucket con il proprio cognome o nome.cognome all'interno di quel bucket e' possibile scrivere, leggere e creare cartelle dentro il bucket scratch tutti possono leggere e scaricare tutto, ma possono solo scrivere in scratch/<cognome> o, se mancante, crearla. Di seguito la spiegazione di come queste policy sono configurate in opa","title":"Test delle default OPA policies in questo setup"},{"location":"Opa/#esempio-di-creazione-policy-opa-usando-token-claims-iam-in-minio","text":"Un tipico input che arriva al server OPA da Minio dopo l'autenticazione con token IAM e' in questa forma: { \"input\" : { \"account\" : \"Z........................BI\" , \"action\" : \"s3:CreateBucket\" , \"bucket\" : \"ciangottini\" , \"conditions\" : { \"Accept-Encoding\" : [ \"identity\" ], \"Authorization\" : [ \"AWS4-HMAC-SHA256 Credential=ZX4QOC80CNLHIBCLG7BI/20200423/us-east-1/s3/aws4_request, SignedHeaders=host;user-agent;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=2926934a3a1380ff8c80c20faeb187a2ddcc42b47a9075fb111987c890811618\" ], \"Content-Length\" : [ \"0\" ], \"CurrentTime\" : [ \"2020-04-23T09:09:31Z\" ], \"EpochTime\" : [ \"1587632971\" ], \"Referer\" : [ \"\" ], \"SecureTransport\" : [ \"false\" ], \"SourceIp\" : [ \"188.XX3.77.XX\" ], \"User-Agent\" : [ \"MinIO (Linux; x86_64) minio-py/5.0.10\" ], \"UserAgent\" : [ \"MinIO (Linux; x86_64) minio-py/5.0.10\" ], \"X-Amz-Content-Sha256\" : [ \"e3b.................852b855\" ], \"X-Amz-Date\" : [ \"20200423T090933Z\" ], \"X-Amz-Security-Token\" : [ \"eyJhbGciO............vqgpJO9vWgQ3oc3tDOnP4A\" ], \"accessKey\" : [ \"ZX4QOC80CNLHIBCLG7BI\" ], \"aud\" : [ \"b8.........................d0d9\" ], \"email\" : [ \"ciangottini@pg.infn.it\" ], \"iss\" : [ \"https://iam.cloud.infn.it/\" ], \"jti\" : [ \"ffe5...................ce4e\" ], \"kid\" : [ \"rsa1\" ], \"name\" : [ \"Diego Ciangottini\" ], \"organisation_name\" : [ \"infn-cc\" ], \"preferred_username\" : [ \"ciangottini@infn.it\" ], \"principaltype\" : [ \"User\" ], \"sub\" : [ \"2f8......................286\" ], \"userid\" : [ \"ZX................BI\" ], \"username\" : [ \"ZX4..................BI\" ] }, \"owner\" : false , { \"action\" : \"s3:GetObject\" }, \"object\" : \"\" , \"claims\" : { \"accessKey\" : \"................LG7BI\" , \"aud\" : \"b830.........................07d0d9\" , \"email\" : \"ciangottini@pg.infn.it\" , \"exp\" : 1587633250 , \"groups\" : [ \"developers\" ], \"iat\" : 1587632650 , \"iss\" : \"https://iam.cloud.infn.it/\" , \"jti\" : \"ffe5.......7ce4e\" , \"kid\" : \"rsa1\" , \"name\" : \"Diego Ciangottini\" , \"organisation_name\" : \"infn-cc\" , \"preferred_username\" : \"ciangottini@infn.it\" , \"sub\" : \"2f8d..............61d89286\" } Tutti questi parametri possono essere utilizzati da OPA per decidere se autorizzare o no la richiesta. Si vede inoltre che MINIO ha processato l' id_token dell'utente ricavandone i campi claims . Nel nostro esempio abbiamo due principali categorie di permessi: user e scratch . Nel primo vogliamo autorizzare praticamente qualsiasi operazione s3, mentre nell'altro, vogliamo che solo il list e il get dei file sia permesso. Questo e' rappresentato nel file di default policy che abbiamo creato con: package httpapi . authz import input default allow = false # role-permissions assignments rl_permissions : = { \"user\" : [{ \"action\" : \"s3:CreateBucket\" }, { \"action\" : \"s3:DeleteBucket\" }, { \"action\" : \"s3:DeleteObject\" }, { \"action\" : \"s3:GetObject\" }, { \"action\" : \"s3:ListAllMyBuckets\" }, { \"action\" : \"s3:ListBucket\" }, { \"action\" : \"s3:PutObject\" }], \"scratch\" : [{ \"action\" : \"s3:ListAllMyBuckets\" }, { \"action\" : \"s3:GetObject\" }, { \"action\" : \"s3:ListBucket\" }] } Ora possiamo decidere in quali casi applicare questi permessi sulla base degli input visti prima. Iniziamo dal bucket utente, vogliamo autorizzare a creare ed operare su un determinato bucket solo le richieste che arrivano con un claim di tipo email nelle forma <bucket name>@... . Cosi che nel caso IAM INFN cloud l'utente possa scrivere nel bucket a suo nome.cognome o cognome . # Allow users to manage their own data. allow { # Extract username from email username : = split ( lower ( input . claims . preferred_username ), \"@\" )[ 0 ] # verify that bucketname == username input . bucket == username # apply only when token auth happened # This is needed to keep admin user and password with full powers input . claims . organisation_name == \"infn-cc\" # Apply user permissions to this request permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } Per quanto riguarda il bucket scratch invece, vogliamo che chiunque abbia i permessi scratch definiti sopra, quindi: # Allow to retrieve and see data from other users in scratch area allow { input . bucket == \"scratch\" permissions : = rl_permissions [ \"scratch\" ] p : = permissions [ _ ] # check if the permission granted to r matches the user request p == { \"action\" : input . action } } Mentre per limitare un subrange di chiamate a path del tipo scratch/<cognome> abbiamo bisogno di prendere altri input dalla richiesta e verificarli come segue: allow { username : = split ( lower ( input . claims . preferred_username ), \"@\" )[ 0 ] ref : = input . conditions . Referer [ _ ] url : = concat ( \"/\" , [ \"^http://.*:9000/minio/scratch\" , username , \".*$\" ] ) re_match ( url , ref ) input . claims . organisation_name == \"infn-cc\" permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } Infine vogliamo mantenere tutti i poter per l'autenticazione user e password dell'admin: allow { input . account == \"minioadmin\" permissions : = rl_permissions [ \"user\" ] p : = permissions [ _ ] p == { \"action\" : input . action } } A questo punto se non fossero gia incluse di default in questo deployment, potremmo inserire nuove policy in opa con un semplice curl: curl -X PUT --data-binary @policy.rego http://localhost:8181/v1/policies/users","title":"Esempio di creazione policy OPA usando token claims IAM in Minio"},{"location":"Opa/#debugging-opa","text":"I log sono visibili (per ora) in debug mode qui: docker logs --tail 2000 minio-opa_opa_1","title":"Debugging OPA"},{"location":"Opa/#debugging-minio","text":"Installare client mc Configurarlo per accesso admin mc config host add myminio http://localhost:9000 minioadmin minioadmin stampare il trace http con mc admin trace myminio","title":"Debugging Minio"},{"location":"RClone/","text":"Quick start Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/ Setup Oidc-agent as describe here cd examples && pip3 install --user -r requirements.txt curl https://rclone.org/install.sh | sudo bash TOKEN= oidc-token demo python3 rclone.py this will use the id_token provided retrieve minio credentials check if the user bucket exists and create it if not mount all the user buckets in /tmp/ do some operation unmount the volume (opional and commented) and exit Code walk-through First of all you have to get your IAM token from oidc-agent and put it into TOKEN env variable. export TOKEN = ` oidc-token demo ` then in the python code you can recall it with: import os token = os . getenv ( \"TOKEN\" ) Now you need to use this token to retrieve your Minio S3 temporary credentials. One way to do this is as follows: import requests import xmltodict r = requests . post ( \"https://131.154.97.121:9001\" , data = { 'Action' : \"AssumeRoleWithWebIdentity\" , 'Version' : \"2011-06-15\" , 'WebIdentityToken' : token , 'DurationSeconds' : 900 }, verify = 'MINIO.pem' ) print ( r . status_code , r . reason ) tree = xmltodict . parse ( r . content ) credenstials = dict ( tree [ 'AssumeRoleWithWebIdentityResponse' ] [ 'AssumeRoleWithWebIdentityResult' ][ 'Credentials' ]) You have now a set of valid credentials composed by an accessID, a secret, and a session token: print ( \"accessID:\" , credenstials [ 'AccessKeyId' ]) print ( \"secret:\" , credenstials [ 'SecretAccessKey' ]) print ( \"session token:\" , credenstials [ 'SessionToken' ]) Now before mounting your bucket with RClone, you might want to check if the bucket with your username exists, and in case not, to create one. You can do it easily with the MINIO python APIs: import jwt from minio import Minio from minio.error import ( ResponseError , BucketAlreadyOwnedByYou , BucketAlreadyExists ) # Get username from your token username = jwt . decode ( token , verify = False )[ 'preferred_username' ] . lower () . split ( \"@\" )[ 0 ] # Prepare the local directory, where you will mount your bucket directory = \"/tmp/\" + username if not os . path . exists ( directory ): os . makedirs ( directory ) # Initialize Minio client minioClient = Minio ( '131.154.97.121:9001' , access_key = credenstials [ 'AccessKeyId' ], secret_key = credenstials [ 'SecretAccessKey' ], session_token = credenstials [ 'SessionToken' ], secure = True , http_client = urllib3 . PoolManager ( timeout = urllib3 . Timeout . DEFAULT_TIMEOUT , cert_reqs = 'CERT_REQUIRED' , ca_certs = \"MINIO.pem\" , ) ) # Make a bucket with the make_bucket API call. Skip if already exists try : minioClient . make_bucket ( username ) except BucketAlreadyOwnedByYou : pass except BucketAlreadyExists : pass except ResponseError as err : raise err Now we are ready to configure RClone with our endpoint and credentials as follow: # Write rclone config file in $PWD/<username>.conf config = \"\"\" [ %s ] type = s3 provider = Minio env_auth = true access_key_id = secret_access_key = session_token = endpoint = https:// %s :9001 \"\"\" % ( username , '131.154.97.121' ) with open ( \" %s .conf\" % username , \"w\" ) as conf_file : conf_file . write ( config ) # Set env vars with credentials os . environ [ 'AWS_ACCESS_KEY' ] = credenstials [ 'AccessKeyId' ] os . environ [ 'AWS_SECRET_KEY' ] = credenstials [ 'SecretAccessKey' ] os . environ [ 'AWS_SESSION_TOKEN' ] = credenstials [ 'SessionToken' ] print ( \"export AWS_ACCESS_KEY= %s \" % credenstials [ 'AccessKeyId' ]) print ( \"export AWS_SECRET_KEY= %s \" % credenstials [ 'SecretAccessKey' ]) print ( \"export AWS_SESSION_TOKEN= %s \" % credenstials [ 'SessionToken' ]) Before mounting our volume, let's check if there is anything mounted and in case umounting it: # Unmount volume if already present myCmd = os . popen ( 'fusermount -u /tmp/ %s ' % username ) . read () print ( myCmd ) It's all set now. Let's mount our volume and access data on it just like a normal posix: # Mount all user buckets myCmd = os . popen ( 'rclone --ca-cert MINIO.pem --config %s .conf mount --daemon --vfs-cache-mode full --no-modtime %s : /tmp/ %s && sleep 2' % ( username , username , username )) . read () print ( myCmd ) # List contents of user buckets myCmd = os . popen ( 'ls -ltrh /tmp/ %s /*/' % ( username )) . read () print ( myCmd ) # Write a posix file filename = \" %s .txt\" % uuid . uuid1 () with open ( \"/tmp/ %s / %s / %s \" % ( username , username , filename ) , \"w\" ) as text_file : text_file . write ( \"the file name is %s \\n\\n \" % filename ) text_file . write ( \"and the file has been created by %s \\n\\n \" % username ) That's it. Now you can exit and start doing thing with your mounted volume. N.B. Be careful though, your credentials are limited to 1h, after that you need to unmount and remount with new credentials. There is a PR that is in preparation to make RClone talk with oidc-agent for an automatic refresh of the credentials. Unmount the volume fusermount -u <path to your volume>","title":"Posix con RClone"},{"location":"RClone/#quick-start","text":"Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/ Setup Oidc-agent as describe here cd examples && pip3 install --user -r requirements.txt curl https://rclone.org/install.sh | sudo bash TOKEN= oidc-token demo python3 rclone.py this will use the id_token provided retrieve minio credentials check if the user bucket exists and create it if not mount all the user buckets in /tmp/ do some operation unmount the volume (opional and commented) and exit","title":"Quick start"},{"location":"RClone/#code-walk-through","text":"First of all you have to get your IAM token from oidc-agent and put it into TOKEN env variable. export TOKEN = ` oidc-token demo ` then in the python code you can recall it with: import os token = os . getenv ( \"TOKEN\" ) Now you need to use this token to retrieve your Minio S3 temporary credentials. One way to do this is as follows: import requests import xmltodict r = requests . post ( \"https://131.154.97.121:9001\" , data = { 'Action' : \"AssumeRoleWithWebIdentity\" , 'Version' : \"2011-06-15\" , 'WebIdentityToken' : token , 'DurationSeconds' : 900 }, verify = 'MINIO.pem' ) print ( r . status_code , r . reason ) tree = xmltodict . parse ( r . content ) credenstials = dict ( tree [ 'AssumeRoleWithWebIdentityResponse' ] [ 'AssumeRoleWithWebIdentityResult' ][ 'Credentials' ]) You have now a set of valid credentials composed by an accessID, a secret, and a session token: print ( \"accessID:\" , credenstials [ 'AccessKeyId' ]) print ( \"secret:\" , credenstials [ 'SecretAccessKey' ]) print ( \"session token:\" , credenstials [ 'SessionToken' ]) Now before mounting your bucket with RClone, you might want to check if the bucket with your username exists, and in case not, to create one. You can do it easily with the MINIO python APIs: import jwt from minio import Minio from minio.error import ( ResponseError , BucketAlreadyOwnedByYou , BucketAlreadyExists ) # Get username from your token username = jwt . decode ( token , verify = False )[ 'preferred_username' ] . lower () . split ( \"@\" )[ 0 ] # Prepare the local directory, where you will mount your bucket directory = \"/tmp/\" + username if not os . path . exists ( directory ): os . makedirs ( directory ) # Initialize Minio client minioClient = Minio ( '131.154.97.121:9001' , access_key = credenstials [ 'AccessKeyId' ], secret_key = credenstials [ 'SecretAccessKey' ], session_token = credenstials [ 'SessionToken' ], secure = True , http_client = urllib3 . PoolManager ( timeout = urllib3 . Timeout . DEFAULT_TIMEOUT , cert_reqs = 'CERT_REQUIRED' , ca_certs = \"MINIO.pem\" , ) ) # Make a bucket with the make_bucket API call. Skip if already exists try : minioClient . make_bucket ( username ) except BucketAlreadyOwnedByYou : pass except BucketAlreadyExists : pass except ResponseError as err : raise err Now we are ready to configure RClone with our endpoint and credentials as follow: # Write rclone config file in $PWD/<username>.conf config = \"\"\" [ %s ] type = s3 provider = Minio env_auth = true access_key_id = secret_access_key = session_token = endpoint = https:// %s :9001 \"\"\" % ( username , '131.154.97.121' ) with open ( \" %s .conf\" % username , \"w\" ) as conf_file : conf_file . write ( config ) # Set env vars with credentials os . environ [ 'AWS_ACCESS_KEY' ] = credenstials [ 'AccessKeyId' ] os . environ [ 'AWS_SECRET_KEY' ] = credenstials [ 'SecretAccessKey' ] os . environ [ 'AWS_SESSION_TOKEN' ] = credenstials [ 'SessionToken' ] print ( \"export AWS_ACCESS_KEY= %s \" % credenstials [ 'AccessKeyId' ]) print ( \"export AWS_SECRET_KEY= %s \" % credenstials [ 'SecretAccessKey' ]) print ( \"export AWS_SESSION_TOKEN= %s \" % credenstials [ 'SessionToken' ]) Before mounting our volume, let's check if there is anything mounted and in case umounting it: # Unmount volume if already present myCmd = os . popen ( 'fusermount -u /tmp/ %s ' % username ) . read () print ( myCmd ) It's all set now. Let's mount our volume and access data on it just like a normal posix: # Mount all user buckets myCmd = os . popen ( 'rclone --ca-cert MINIO.pem --config %s .conf mount --daemon --vfs-cache-mode full --no-modtime %s : /tmp/ %s && sleep 2' % ( username , username , username )) . read () print ( myCmd ) # List contents of user buckets myCmd = os . popen ( 'ls -ltrh /tmp/ %s /*/' % ( username )) . read () print ( myCmd ) # Write a posix file filename = \" %s .txt\" % uuid . uuid1 () with open ( \"/tmp/ %s / %s / %s \" % ( username , username , filename ) , \"w\" ) as text_file : text_file . write ( \"the file name is %s \\n\\n \" % filename ) text_file . write ( \"and the file has been created by %s \\n\\n \" % username ) That's it. Now you can exit and start doing thing with your mounted volume. N.B. Be careful though, your credentials are limited to 1h, after that you need to unmount and remount with new credentials. There is a PR that is in preparation to make RClone talk with oidc-agent for an automatic refresh of the credentials.","title":"Code walk-through"},{"location":"RClone/#unmount-the-volume","text":"fusermount -u <path to your volume>","title":"Unmount the volume"},{"location":"WebUI/","text":"Usare WebUI Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/ Requirement Registrare un account in IAM-demo Login with IAM-demo With your browser visit https://131.154.97.121:9001/ Click on Login with OpenID Insert the credentials that you get on the requirement step above Now you should be allowed to login and see something like You probably don't have any folder or bucket ready. So let's create a new bucket now. Create a bucket with your IAM username From the bottom right corner select Create bucket and user your IAM login name. As you are allowed by OPA setup to create only a bucket with you IAM username. Then select the bucket on the left bar. We are now ready to upload a file. Upload a file From the bottom right corner select Upload Chose a file from your filesystem and click ok The file should be now visible on the WebUI","title":"WebUI"},{"location":"WebUI/#usare-webui","text":"Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/","title":"Usare WebUI"},{"location":"WebUI/#requirement","text":"Registrare un account in IAM-demo","title":"Requirement"},{"location":"WebUI/#login-with-iam-demo","text":"With your browser visit https://131.154.97.121:9001/ Click on Login with OpenID Insert the credentials that you get on the requirement step above Now you should be allowed to login and see something like You probably don't have any folder or bucket ready. So let's create a new bucket now.","title":"Login with IAM-demo"},{"location":"WebUI/#create-a-bucket-with-your-iam-username","text":"From the bottom right corner select Create bucket and user your IAM login name. As you are allowed by OPA setup to create only a bucket with you IAM username. Then select the bucket on the left bar. We are now ready to upload a file.","title":"Create a bucket with your IAM username"},{"location":"WebUI/#upload-a-file","text":"From the bottom right corner select Upload Chose a file from your filesystem and click ok The file should be now visible on the WebUI","title":"Upload a file"},{"location":"s3/","text":"Quick start Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/ Setup Oidc-agent as describe here cd examples && pip3 install --user -r requirements.txt curl https://rclone.org/install.sh | sudo bash TOKEN= oidc-token demo python3 s3_api.py this will use the id_token provided retrieve minio credentials check if the user bucket exists and create it if not do some operation with S3 python api and exit Code walk-through First of all you have to get your IAM token from oidc-agent and put it into TOKEN env variable. export TOKEN = ` oidc-token demo ` then in the python code you can recall it with: import os token = os . getenv ( \"TOKEN\" ) Now you need to use this token to retrieve your Minio S3 temporary credentials. One way to do this is as follows: import requests import xmltodict r = requests . post ( \"https://131.154.97.121:9001\" , data = { 'Action' : \"AssumeRoleWithWebIdentity\" , 'Version' : \"2011-06-15\" , 'WebIdentityToken' : token , 'DurationSeconds' : 900 }, verify = 'MINIO.pem' ) print ( r . status_code , r . reason ) tree = xmltodict . parse ( r . content ) credenstials = dict ( tree [ 'AssumeRoleWithWebIdentityResponse' ] [ 'AssumeRoleWithWebIdentityResult' ][ 'Credentials' ]) You have now a set of valid credentials composed by an accessID, a secret, and a session token: print ( \"accessID:\" , credenstials [ 'AccessKeyId' ]) print ( \"secret:\" , credenstials [ 'SecretAccessKey' ]) print ( \"session token:\" , credenstials [ 'SessionToken' ]) Now before mounting your bucket with RClone, you might want to check if the bucket with your username exists, and in case not, to create one. You can do it easily with the MINIO python APIs: import jwt from minio import Minio from minio.error import ( ResponseError , BucketAlreadyOwnedByYou , BucketAlreadyExists ) # Get username from your token username = jwt . decode ( token , verify = False )[ 'preferred_username' ] . lower () . split ( \"@\" )[ 0 ] # Prepare the local directory, where you will mount your bucket directory = \"/tmp/\" + username if not os . path . exists ( directory ): os . makedirs ( directory ) # Initialize Minio client minioClient = Minio ( '131.154.97.121:9001' , access_key = credenstials [ 'AccessKeyId' ], secret_key = credenstials [ 'SecretAccessKey' ], session_token = credenstials [ 'SessionToken' ], secure = True , http_client = urllib3 . PoolManager ( timeout = urllib3 . Timeout . DEFAULT_TIMEOUT , cert_reqs = 'CERT_REQUIRED' , ca_certs = \"MINIO.pem\" , ) ) # Make a bucket with the make_bucket API call. Skip if already exists try : minioClient . make_bucket ( username ) except BucketAlreadyOwnedByYou : pass except BucketAlreadyExists : pass except ResponseError as err : raise err Now it's all set, you can start to leverage MINIO client for doing whatever you like. Listing buckets: buckets = minioClient . list_buckets () for bucket in buckets : print ( bucket . name , bucket . creation_date ) Loading a file on a subdirectory of your bucket: import uuid #uniq file name just for lazy testing filename = \" %s .txt\" % uuid . uuid1 () #put a object in a sub-directory of the bucket try : with open ( 'requirements.txt' , 'rb' ) as file_data : file_stat = os . stat ( 'requirements.txt' ) minioClient . put_object ( username , 'my_object/test_objec_ %s ' % filename , file_data , file_stat . st_size ) except ResponseError as err : print ( err ) Streaming data into MINIO: # streaming data to a directory within the bucket data = \"I want to stream some test to minio\" data_bytes = data . encode ( 'utf-8' ) data_stream = io . BytesIO ( data_bytes ) try : minioClient . put_object ( username , \"my_stream/test_stream_ %s \" % filename , data_stream , len ( data_bytes )) except Exception as ex : raise ex","title":"S3 APIs"},{"location":"s3/#quick-start","text":"Per questo quick-start usiamo un deployment gia' pronto installato come descritto qui . Raggiungibile a https://131.154.97.121:9001/ Setup Oidc-agent as describe here cd examples && pip3 install --user -r requirements.txt curl https://rclone.org/install.sh | sudo bash TOKEN= oidc-token demo python3 s3_api.py this will use the id_token provided retrieve minio credentials check if the user bucket exists and create it if not do some operation with S3 python api and exit","title":"Quick start"},{"location":"s3/#code-walk-through","text":"First of all you have to get your IAM token from oidc-agent and put it into TOKEN env variable. export TOKEN = ` oidc-token demo ` then in the python code you can recall it with: import os token = os . getenv ( \"TOKEN\" ) Now you need to use this token to retrieve your Minio S3 temporary credentials. One way to do this is as follows: import requests import xmltodict r = requests . post ( \"https://131.154.97.121:9001\" , data = { 'Action' : \"AssumeRoleWithWebIdentity\" , 'Version' : \"2011-06-15\" , 'WebIdentityToken' : token , 'DurationSeconds' : 900 }, verify = 'MINIO.pem' ) print ( r . status_code , r . reason ) tree = xmltodict . parse ( r . content ) credenstials = dict ( tree [ 'AssumeRoleWithWebIdentityResponse' ] [ 'AssumeRoleWithWebIdentityResult' ][ 'Credentials' ]) You have now a set of valid credentials composed by an accessID, a secret, and a session token: print ( \"accessID:\" , credenstials [ 'AccessKeyId' ]) print ( \"secret:\" , credenstials [ 'SecretAccessKey' ]) print ( \"session token:\" , credenstials [ 'SessionToken' ]) Now before mounting your bucket with RClone, you might want to check if the bucket with your username exists, and in case not, to create one. You can do it easily with the MINIO python APIs: import jwt from minio import Minio from minio.error import ( ResponseError , BucketAlreadyOwnedByYou , BucketAlreadyExists ) # Get username from your token username = jwt . decode ( token , verify = False )[ 'preferred_username' ] . lower () . split ( \"@\" )[ 0 ] # Prepare the local directory, where you will mount your bucket directory = \"/tmp/\" + username if not os . path . exists ( directory ): os . makedirs ( directory ) # Initialize Minio client minioClient = Minio ( '131.154.97.121:9001' , access_key = credenstials [ 'AccessKeyId' ], secret_key = credenstials [ 'SecretAccessKey' ], session_token = credenstials [ 'SessionToken' ], secure = True , http_client = urllib3 . PoolManager ( timeout = urllib3 . Timeout . DEFAULT_TIMEOUT , cert_reqs = 'CERT_REQUIRED' , ca_certs = \"MINIO.pem\" , ) ) # Make a bucket with the make_bucket API call. Skip if already exists try : minioClient . make_bucket ( username ) except BucketAlreadyOwnedByYou : pass except BucketAlreadyExists : pass except ResponseError as err : raise err Now it's all set, you can start to leverage MINIO client for doing whatever you like. Listing buckets: buckets = minioClient . list_buckets () for bucket in buckets : print ( bucket . name , bucket . creation_date ) Loading a file on a subdirectory of your bucket: import uuid #uniq file name just for lazy testing filename = \" %s .txt\" % uuid . uuid1 () #put a object in a sub-directory of the bucket try : with open ( 'requirements.txt' , 'rb' ) as file_data : file_stat = os . stat ( 'requirements.txt' ) minioClient . put_object ( username , 'my_object/test_objec_ %s ' % filename , file_data , file_stat . st_size ) except ResponseError as err : print ( err ) Streaming data into MINIO: # streaming data to a directory within the bucket data = \"I want to stream some test to minio\" data_bytes = data . encode ( 'utf-8' ) data_stream = io . BytesIO ( data_bytes ) try : minioClient . put_object ( username , \"my_stream/test_stream_ %s \" % filename , data_stream , len ( data_bytes )) except Exception as ex : raise ex","title":"Code walk-through"},{"location":"quick-start/linux/","text":"Automatic posix mount point for Minio demo bucket Requirements a user bucket created following WebUI guide Using STS-Wire CLI Download the STS-Wire utility to get you credentials and mount your bucket in one go: wget https://github.com/dciangot/sts-wire/releases/download/v0.0.1/sts-wire_linux To use it, you need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): chmod +x ./sts-wire_linux ./sts-wire_linux myminio / ./mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"Linux"},{"location":"quick-start/linux/#automatic-posix-mount-point-for-minio-demo-bucket","text":"","title":"Automatic posix mount point for Minio demo bucket"},{"location":"quick-start/linux/#requirements","text":"a user bucket created following WebUI guide","title":"Requirements"},{"location":"quick-start/linux/#using-sts-wire-cli","text":"Download the STS-Wire utility to get you credentials and mount your bucket in one go: wget https://github.com/dciangot/sts-wire/releases/download/v0.0.1/sts-wire_linux To use it, you need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): chmod +x ./sts-wire_linux ./sts-wire_linux myminio / ./mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"Using STS-Wire CLI"},{"location":"quick-start/osx/","text":"Automatic posix mount point for Minio demo bucket Requirements a user bucket created following WebUI guide Using STS-Wire CLI Download the STS-Wire utility to get you credentials and mount your bucket in one go: wget https://github.com/dciangot/sts-wire/releases/download/v0.0.1/sts-wire_osx To use it, you need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): chmod +x ./sts-wire_osx ./sts-wire_osx myminio / ./mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"MacOS"},{"location":"quick-start/osx/#automatic-posix-mount-point-for-minio-demo-bucket","text":"","title":"Automatic posix mount point for Minio demo bucket"},{"location":"quick-start/osx/#requirements","text":"a user bucket created following WebUI guide","title":"Requirements"},{"location":"quick-start/osx/#using-sts-wire-cli","text":"Download the STS-Wire utility to get you credentials and mount your bucket in one go: wget https://github.com/dciangot/sts-wire/releases/download/v0.0.1/sts-wire_osx To use it, you need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): chmod +x ./sts-wire_osx ./sts-wire_osx myminio / ./mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"Using STS-Wire CLI"},{"location":"quick-start/windows/","text":"Automatic posix mount point for Minio demo bucket Requirements a user bucket created following WebUI guide WinSFP installed. Guide here Using STS-Wire CLI Download the STS-Wire utility to get you credentials and mount your bucket in one go. Run the following command in Powershell from the location where you did download the STS-Wire utility. Then you will need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): .\\sts-wire_windows.exe myminio / .\\mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"Windows"},{"location":"quick-start/windows/#automatic-posix-mount-point-for-minio-demo-bucket","text":"","title":"Automatic posix mount point for Minio demo bucket"},{"location":"quick-start/windows/#requirements","text":"a user bucket created following WebUI guide WinSFP installed. Guide here","title":"Requirements"},{"location":"quick-start/windows/#using-sts-wire-cli","text":"Download the STS-Wire utility to get you credentials and mount your bucket in one go. Run the following command in Powershell from the location where you did download the STS-Wire utility. Then you will need to provide an instance name (of your choice, it is just for storing IAM client configuration, e.g. myminio ), the path to your bucket or to root / , and finally the mount point destination (in this example ./mountedVolume ): .\\sts-wire_windows.exe myminio / .\\mountedVolume Follow all the instructions, providing a password for credentials encryption when requested. Eventually, if everything went fine, on your browser you will be prompted with a message like: VOLUME MOUNTED, YOU CAN NOW CLOSE THIS TAB. The volume will stay mounted untill you exit the running sts-wire process with Control-C.","title":"Using STS-Wire CLI"}]}